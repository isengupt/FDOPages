{"version":3,"file":"easy-peasy.js","sources":["../src/context.js","../src/hooks.js","../src/helpers.js","../src/lib.js","../src/create-reducer.js","../src/persistence.js","../src/listeners.js","../src/computed-properties.js","../src/effects.js","../src/create-store.js","../src/create-store-internals.js","../src/extract-data-from-model.js","../src/constants.js","../src/actions.js","../src/thunks.js","../src/create-component-store.js","../src/index.js","../src/provider.js","../src/create-context-store.js","../src/create-transform.js","../src/use-local-store.js"],"sourcesContent":["import { createContext } from 'react';\n\nconst StoreContext = createContext();\n\nexport default StoreContext;\n","import {\n  useContext,\n  useEffect,\n  useLayoutEffect,\n  useReducer,\n  useRef,\n  useState,\n} from 'react';\nimport EasyPeasyContext from './context';\n\n// React currently throws a warning when using useLayoutEffect on the server.\n// To get around it, we can conditionally useEffect on the server (no-op) and\n// useLayoutEffect in the browser. We need useLayoutEffect to ensure the store\n// subscription callback always has the selector from the latest render commit\n// available, otherwise a store update may happen between render and the effect,\n// which may cause missed updates; we also must ensure the store subscription\n// is created synchronously, otherwise a store update may occur before the\n// subscription is created and an inconsistent state may be observed\nconst useIsomorphicLayoutEffect =\n  typeof window !== 'undefined' ? useLayoutEffect : useEffect;\n\nexport function createStoreStateHook(Context) {\n  return function useStoreState(mapState, equalityFn) {\n    const store = useContext(Context);\n    const mapStateRef = useRef(mapState);\n    const stateRef = useRef();\n    const mountedRef = useRef(true);\n    const subscriptionMapStateError = useRef();\n\n    const [, forceRender] = useReducer((s) => s + 1, 0);\n\n    if (\n      subscriptionMapStateError.current ||\n      mapStateRef.current !== mapState ||\n      stateRef.current === undefined\n    ) {\n      try {\n        stateRef.current = mapState(store.getState());\n      } catch (err) {\n        if (process.env.NODE_ENV === 'development') {\n          let errorMessage = `An error occurred trying to map state in a useStoreState hook: ${err.message}.`;\n          if (subscriptionMapStateError.current) {\n            errorMessage += `\\nThis error may be related to the following error:\\n${subscriptionMapStateError.current.stack}\\n\\nOriginal stack trace:`;\n          }\n          throw new Error(errorMessage);\n        }\n        throw subscriptionMapStateError.current || err;\n      }\n    }\n\n    useIsomorphicLayoutEffect(() => {\n      mapStateRef.current = mapState;\n      subscriptionMapStateError.current = undefined;\n    });\n\n    useIsomorphicLayoutEffect(() => {\n      const checkMapState = () => {\n        try {\n          const newState = mapStateRef.current(store.getState());\n\n          const isStateEqual =\n            typeof equalityFn === 'function'\n              ? equalityFn(stateRef.current, newState)\n              : stateRef.current === newState;\n\n          if (isStateEqual) {\n            return;\n          }\n\n          stateRef.current = newState;\n        } catch (err) {\n          // see https://github.com/reduxjs/react-redux/issues/1179\n          // There is a possibility mapState will fail due to stale state or\n          // props, therefore we will just track the error and force our\n          // component to update. It should then receive the updated state\n          subscriptionMapStateError.current = err;\n        }\n        if (mountedRef.current) {\n          forceRender({});\n        }\n      };\n      const unsubscribe = store.subscribe(checkMapState);\n      checkMapState();\n      return () => {\n        mountedRef.current = false;\n        unsubscribe();\n      };\n    }, []);\n\n    return stateRef.current;\n  };\n}\n\nexport const useStoreState = createStoreStateHook(EasyPeasyContext);\n\nexport function createStoreActionsHook(Context) {\n  return function useStoreActions(mapActions) {\n    const store = useContext(Context);\n    return mapActions(store.getActions());\n  };\n}\n\nexport const useStoreActions = createStoreActionsHook(EasyPeasyContext);\n\nexport function createStoreDispatchHook(Context) {\n  return function useStoreDispatch() {\n    const store = useContext(Context);\n    return store.dispatch;\n  };\n}\n\nexport const useStoreDispatch = createStoreDispatchHook(EasyPeasyContext);\n\nexport function useStore() {\n  return useContext(EasyPeasyContext);\n}\n\nexport function createStoreRehydratedHook(Context) {\n  return function useStoreRehydrated() {\n    const store = useContext(Context);\n    const [rehydrated, setRehydrated] = useState(false);\n    useEffect(() => {\n      store.persist.resolveRehydration().then(() => setRehydrated(true));\n    }, []);\n    return rehydrated;\n  };\n}\n\nexport const useStoreRehydrated = createStoreRehydratedHook(EasyPeasyContext);\n\nexport function createTypedHooks() {\n  return {\n    useStoreActions,\n    useStoreDispatch,\n    useStoreState,\n    useStoreRehydrated,\n    useStore,\n  };\n}\n","import { isDraft, current } from 'immer';\nimport memoizerific from 'memoizerific';\nimport {\n  actionOnSymbol,\n  actionSymbol,\n  computedSymbol,\n  effectOnSymbol,\n  persistSymbol,\n  reducerSymbol,\n  thunkOnSymbol,\n  thunkSymbol,\n} from './constants';\n\nexport const debug = (state) => {\n  if (isDraft(state)) {\n    return current(state);\n  }\n  return state;\n};\n\nexport const memo = (fn, cacheSize) => memoizerific(cacheSize)(fn);\n\nexport const actionOn = (targetResolver, fn) => {\n  return {\n    [actionOnSymbol]: true,\n    fn,\n    targetResolver,\n  };\n};\n\nexport const action = (fn) => {\n  return {\n    [actionSymbol]: true,\n    fn,\n  };\n};\n\nconst defaultStateResolvers = [(state) => state];\n\nexport const computed = (fnOrStateResolvers, fn) => {\n  if (typeof fn === 'function') {\n    return {\n      [computedSymbol]: true,\n      fn,\n      stateResolvers: fnOrStateResolvers,\n    };\n  }\n  return {\n    [computedSymbol]: true,\n    fn: fnOrStateResolvers,\n    stateResolvers: defaultStateResolvers,\n  };\n};\n\nexport function unstable_effectOn(dependencyResolvers, fn) {\n  return {\n    [effectOnSymbol]: true,\n    dependencyResolvers,\n    fn,\n  };\n}\n\nexport function generic(value) {\n  return value;\n}\n\nexport const persist = (model, config) => {\n  // if we are not running in a browser context this becomes a no-op\n  return typeof window === 'undefined'\n    ? model\n    : {\n        ...model,\n        [persistSymbol]: config,\n      };\n};\n\nexport const thunkOn = (targetResolver, fn) => {\n  return {\n    [thunkOnSymbol]: true,\n    fn,\n    targetResolver,\n  };\n};\n\nexport const thunk = (fn) => {\n  return {\n    [thunkSymbol]: true,\n    fn,\n  };\n};\n\nexport const reducer = (fn) => {\n  return {\n    [reducerSymbol]: true,\n    fn,\n  };\n};\n","import isPlainObject from 'is-plain-object';\nimport { createDraft, finishDraft, isDraft } from 'immer';\n\nexport const deepCloneStateWithoutComputed = (source) => {\n  const recursiveClone = (current) => {\n    const next = Object.keys(current).reduce((acc, key) => {\n      if (Object.getOwnPropertyDescriptor(current, key).get == null) {\n        acc[key] = current[key];\n      }\n      return acc;\n    }, {});\n    Object.keys(next).forEach((key) => {\n      if (isPlainObject(next[key])) {\n        next[key] = recursiveClone(next[key]);\n      }\n    });\n    return next;\n  };\n  return recursiveClone(source);\n};\n\nexport const isPromise = (x) => {\n  return x != null && typeof x === 'object' && typeof x.then === 'function';\n};\n\nexport function get(path, target) {\n  return path.reduce((acc, cur) => {\n    return isPlainObject(acc) ? acc[cur] : undefined;\n  }, target);\n}\n\nexport function newify(currentPath, currentState, finalValue) {\n  if (currentPath.length === 0) {\n    return finalValue;\n  }\n  const newState = { ...currentState };\n  const key = currentPath[0];\n  if (currentPath.length === 1) {\n    newState[key] = finalValue;\n  } else {\n    newState[key] = newify(currentPath.slice(1), newState[key], finalValue);\n  }\n  return newState;\n}\n\nexport const set = (path, target, value) => {\n  if (path.length === 0) {\n    if (typeof value === 'object') {\n      Object.keys(target).forEach((key) => {\n        delete target[key];\n      });\n      Object.keys(value).forEach((key) => {\n        target[key] = value[key];\n      });\n    }\n    return;\n  }\n  path.reduce((acc, cur, idx) => {\n    if (idx + 1 === path.length) {\n      acc[cur] = value;\n    } else {\n      acc[cur] = acc[cur] || {};\n    }\n    return acc[cur];\n  }, target);\n};\n\nexport function createSimpleProduce(disableImmer = false) {\n  return function simpleProduce(path, state, fn) {\n    if (disableImmer) {\n      const current = get(path, state);\n      const next = fn(current);\n      if (current !== next) {\n        return newify(path, state, next);\n      }\n      return state;\n    }\n    if (path.length === 0) {\n      const draft = createDraft(state);\n      const result = fn(draft);\n      if (result) {\n        return isDraft(result) ? finishDraft(result) : result;\n      }\n      return finishDraft(draft);\n    }\n    const parentPath = path.slice(0, path.length - 1);\n    const draft = createDraft(state);\n    const parent = get(parentPath, state);\n    const current = get(path, draft);\n    const result = fn(current);\n\n    if (result) {\n      parent[path[path.length - 1]] = result;\n    }\n    return finishDraft(draft);\n  };\n}\n","import { createSimpleProduce, get } from './lib';\nimport { actionSymbol, actionOnSymbol } from './constants';\n\nexport default function createReducer(\n  disableImmer,\n  _actionReducersDict,\n  _customReducers,\n  _computedProperties,\n) {\n  const simpleProduce = createSimpleProduce(disableImmer);\n\n  const runActionReducerAtPath = (state, action, actionReducer, path) => {\n    return simpleProduce(path, state, (draft) =>\n      actionReducer(draft, action.payload),\n    );\n  };\n\n  const reducerForActions = (state, action) => {\n    const actionReducer = _actionReducersDict[action.type];\n    if (actionReducer) {\n      return runActionReducerAtPath(\n        state,\n        action,\n        actionReducer,\n        actionReducer.definition.meta.parent,\n      );\n    }\n    return state;\n  };\n\n  const reducerForCustomReducers = (state, action) => {\n    return _customReducers.reduce((acc, { parentPath, key, reducer: red }) => {\n      return simpleProduce(parentPath, acc, (draft) => {\n        draft[key] = red(draft[key], action);\n        return draft;\n      });\n    }, state);\n  };\n\n  const rootReducer = (state, action) => {\n    const stateAfterActions = reducerForActions(state, action);\n    const next =\n      _customReducers.length > 0\n        ? reducerForCustomReducers(stateAfterActions, action)\n        : stateAfterActions;\n    if (state !== next) {\n      _computedProperties.forEach(({ parentPath, bindComputedProperty }) => {\n        const prop = get(parentPath, next);\n        if (prop != null) bindComputedProperty(prop);\n      });\n    }\n    return next;\n  };\n\n  return rootReducer;\n}\n","import debounce from 'debounce';\nimport isPlainObject from 'is-plain-object';\nimport { deepCloneStateWithoutComputed, get, isPromise, set } from './lib';\n\nconst noopStorage = {\n  getItem: () => undefined,\n  setItem: () => undefined,\n  removeItem: () => undefined,\n};\n\nfunction getStorage(storageName) {\n  try {\n    if (\n      typeof window !== 'undefined' &&\n      typeof window[storageName] !== 'undefined'\n    ) {\n      return window[storageName];\n    }\n    return noopStorage;\n  } catch (_) {\n    return noopStorage;\n  }\n}\n\nconst localStorage = getStorage('localStorage');\nconst sessionStorage = getStorage('sessionStorage');\n\nfunction createStorageWrapper(storage = sessionStorage, transformers = []) {\n  if (typeof storage === 'string') {\n    if (storage === 'localStorage') {\n      storage = localStorage;\n    } else if (storage === 'sessionStorage') {\n      storage = sessionStorage;\n    } else {\n      if (process.env.NODE_ENV === 'development') {\n        console.warn(\n          `Invalid storage provider specified for Easy Peasy persist: ${storage}\\nValid values include \"localStorage\", \"sessionStorage\" or a custom storage engine.`,\n        );\n      }\n      storage = noopStorage;\n    }\n  }\n\n  const outTransformers = transformers.reverse();\n\n  const serialize = (data, key) => {\n    const simpleKey = key.substr(key.indexOf('@') + 1);\n    const transformed = transformers.reduce((acc, cur) => {\n      return cur.in(acc, simpleKey);\n    }, data);\n    return storage === localStorage || storage === sessionStorage\n      ? JSON.stringify({ data: transformed })\n      : transformed;\n  };\n  const deserialize = (data, key) => {\n    const simpleKey = key.substr(key.indexOf('@') + 1);\n    const result =\n      storage === localStorage || storage === sessionStorage\n        ? JSON.parse(data).data\n        : data;\n    return outTransformers.reduce((acc, cur) => {\n      return cur.out(acc, simpleKey);\n    }, result);\n  };\n\n  const isAsync = isPromise(storage.getItem('_'));\n\n  return {\n    isAsync,\n    getItem: (key) => {\n      if (isAsync) {\n        return storage.getItem(key).then((wrapped) => {\n          return wrapped != null ? deserialize(wrapped, key) : undefined;\n        });\n      }\n      const wrapped = storage.getItem(key);\n      return wrapped != null ? deserialize(wrapped, key) : undefined;\n    },\n    setItem: (key, data) => {\n      return storage.setItem(key, serialize(data, key));\n    },\n    removeItem: (key) => {\n      return storage.removeItem(key);\n    },\n  };\n}\n\nexport function extractPersistConfig(path, persistDefinition = {}) {\n  return {\n    path,\n    config: {\n      blacklist: persistDefinition.blacklist || [],\n      mergeStrategy: persistDefinition.mergeStrategy || 'merge',\n      storage: createStorageWrapper(\n        persistDefinition.storage,\n        persistDefinition.transformers,\n      ),\n      whitelist: persistDefinition.whitelist || [],\n    },\n  };\n}\n\nfunction resolvePersistTargets(target, whitelist, blacklist) {\n  let targets = Object.keys(target);\n  if (whitelist.length > 0) {\n    targets = targets.reduce((acc, cur) => {\n      if (whitelist.findIndex((x) => x === cur) !== -1) {\n        return [...acc, cur];\n      }\n      return acc;\n    }, []);\n  }\n  if (blacklist.length > 0) {\n    targets = targets.reduce((acc, cur) => {\n      if (blacklist.findIndex((x) => x === cur) !== -1) {\n        return acc;\n      }\n      return [...acc, cur];\n    }, []);\n  }\n  return targets;\n}\n\nfunction createPersistenceClearer(persistKey, references) {\n  return () =>\n    new Promise((resolve, reject) => {\n      references.internals._persistenceConfig.forEach(({ path, config }) => {\n        const { storage, whitelist, blacklist } = config;\n        const persistRoot = get(path, references.getState());\n        const targets = resolvePersistTargets(\n          persistRoot,\n          whitelist,\n          blacklist,\n        );\n        if (targets.length > 0) {\n          Promise.all(\n            targets.map((key) => {\n              const targetPath = [...path, key];\n              return storage.removeItem(persistKey(targetPath));\n            }),\n          ).then(() => resolve(), reject);\n        } else {\n          resolve();\n        }\n      });\n    });\n}\n\nexport function createPersistor(persistKey, references) {\n  let persistPromise = Promise.resolve();\n\n  const persist = debounce(() => {\n    if (references.internals._persistenceConfig.length === 0) {\n      return;\n    }\n    persistPromise = Promise.all(\n      references.internals._persistenceConfig.reduce(\n        (acc, { path, config }) => {\n          const { storage, whitelist, blacklist } = config;\n          const state = references.getState();\n          const persistRoot = deepCloneStateWithoutComputed(get(path, state));\n          const targets = resolvePersistTargets(\n            persistRoot,\n            whitelist,\n            blacklist,\n          );\n          return acc.concat(\n            targets.map((key) => {\n              const targetPath = [...path, key];\n              return Promise.resolve(\n                storage.setItem(persistKey(targetPath), get(targetPath, state)),\n              );\n            }),\n          );\n        },\n        [],\n      ),\n    );\n  }, 1000);\n\n  return {\n    persist,\n    clear: createPersistenceClearer(persistKey, references),\n    flush: async () => {\n      persist.flush();\n      await persistPromise;\n    },\n  };\n}\n\nexport function createPersistMiddleware(persistor, references) {\n  return () => (next) => (action) => {\n    const state = next(action);\n    if (\n      action &&\n      action.type !== '@action.ePRS' &&\n      references.internals._persistenceConfig.length > 0\n    ) {\n      persistor.persist(state);\n    }\n    return state;\n  };\n}\n\nexport function rehydrateStateFromPersistIfNeeded(\n  persistKey,\n  replaceState,\n  references,\n  root,\n) {\n  // If we have any persist configs we will attemp to perform a state rehydration\n  let resolveRehydration = Promise.resolve();\n  if (references.internals._persistenceConfig.length > 0) {\n    references.internals._persistenceConfig.forEach((persistInstance) => {\n      const { path, config } = persistInstance;\n      const { blacklist, mergeStrategy, storage, whitelist } = config;\n\n      if (root && (path.length < 1 || path[0] !== root)) {\n        return;\n      }\n\n      const state = references.internals._defaultState;\n      const persistRoot = deepCloneStateWithoutComputed(get(path, state));\n      const targets = resolvePersistTargets(persistRoot, whitelist, blacklist);\n\n      const hasDataModelChanged = (dataModel, rehydratingModelData) =>\n        dataModel != null &&\n        rehydratingModelData != null &&\n        (typeof dataModel !== typeof rehydratingModelData ||\n          (Array.isArray(dataModel) && !Array.isArray(rehydratingModelData)));\n\n      const applyRehydrationStrategy = (originalState, rehydratedState) => {\n        if (mergeStrategy === 'overwrite') {\n          set(path, originalState, rehydratedState);\n        } else if (mergeStrategy === 'merge') {\n          const target = get(path, originalState);\n          Object.keys(rehydratedState).forEach((key) => {\n            if (hasDataModelChanged(target[key], rehydratedState[key])) {\n              // skip as the data model type has changed since the data was persisted\n            } else {\n              target[key] = rehydratedState[key];\n            }\n          });\n        } else if (mergeStrategy === 'mergeDeep') {\n          const target = get(path, originalState);\n          const setAt = (currentTarget, currentNext) => {\n            Object.keys(currentNext).forEach((key) => {\n              const data = currentNext[key];\n              if (hasDataModelChanged(currentTarget[key], data)) {\n                // skip as the data model type has changed since the data was persisted\n              } else if (isPlainObject(data)) {\n                currentTarget[key] = currentTarget[key] || {};\n                setAt(currentTarget[key], data);\n              } else {\n                currentTarget[key] = data;\n              }\n            });\n          };\n          setAt(target, rehydratedState);\n        }\n      };\n\n      if (storage.isAsync) {\n        const asyncStateResolvers = targets.reduce((acc, key) => {\n          const targetPath = [...path, key];\n          const dataPromise = storage.getItem(persistKey(targetPath));\n          if (isPromise(dataPromise)) {\n            acc.push({\n              key,\n              dataPromise,\n            });\n          }\n          return acc;\n        }, []);\n        if (asyncStateResolvers.length > 0) {\n          resolveRehydration = Promise.all(\n            asyncStateResolvers.map((x) => x.dataPromise),\n          ).then((resolvedData) => {\n            const next = resolvedData.reduce((acc, cur, idx) => {\n              const { key } = asyncStateResolvers[idx];\n              if (cur !== undefined) {\n                acc[key] = cur;\n              }\n              return acc;\n            }, {});\n            if (Object.keys(next).length === 0) {\n              return;\n            }\n            applyRehydrationStrategy(state, next);\n            replaceState(state);\n          });\n        }\n      } else {\n        const next = targets.reduce((acc, key) => {\n          const targetPath = [...path, key];\n          const data = storage.getItem(persistKey(targetPath));\n          if (data !== undefined) {\n            acc[key] = data;\n          }\n          return acc;\n        }, {});\n        applyRehydrationStrategy(state, next);\n        replaceState(state);\n      }\n    });\n  }\n  return resolveRehydration;\n}\n","import { get } from './lib';\n\nexport function createListenerMiddleware(references) {\n  return () => (next) => (action) => {\n    const result = next(action);\n    if (\n      action &&\n      references.internals._listenerActionMap[action.type] &&\n      references.internals._listenerActionMap[action.type].length > 0\n    ) {\n      const sourceAction = references.internals._actionCreatorDict[action.type];\n      references.internals._listenerActionMap[action.type].forEach(\n        (actionCreator) => {\n          actionCreator({\n            type: sourceAction\n              ? sourceAction.definition.meta.type\n              : action.type,\n            payload: action.payload,\n            error: action.error,\n            result: action.result,\n          });\n        },\n      );\n    }\n    return result;\n  };\n}\n\nexport function bindListenerDefinitions(\n  listenerDefinitions,\n  _actionCreators,\n  _actionCreatorDict,\n  _listenerActionMap,\n) {\n  listenerDefinitions.forEach((definition) => {\n    const targets = definition.targetResolver(\n      get(definition.meta.parent, _actionCreators),\n      _actionCreators,\n    );\n\n    const targetTypes = (Array.isArray(targets) ? targets : [targets]).reduce(\n      (acc, target) => {\n        if (\n          typeof target === 'function' &&\n          target.definition.meta.type &&\n          _actionCreatorDict[target.definition.meta.type]\n        ) {\n          acc.push(target.definition.meta.type);\n        } else if (typeof target === 'string') {\n          acc.push(target);\n        }\n        return acc;\n      },\n      [],\n    );\n\n    definition.meta.resolvedTargets = targetTypes;\n\n    targetTypes.forEach((targetType) => {\n      const listenerReg = _listenerActionMap[targetType] || [];\n      listenerReg.push(_actionCreatorDict[definition.meta.type]);\n      _listenerActionMap[targetType] = listenerReg;\n    });\n  });\n}\n","import memoizerific from 'memoizerific';\nimport { get } from './lib';\n\nexport function createComputedPropertyBinder(\n  parentPath,\n  key,\n  definition,\n  _computedState,\n  references,\n) {\n  const memoisedResultFn = memoizerific(1)(definition.fn);\n  return function createComputedProperty(o) {\n    Object.defineProperty(o, key, {\n      configurable: true,\n      enumerable: true,\n      get: () => {\n        let storeState;\n        if (_computedState.isInReducer) {\n          storeState = _computedState.currentState;\n        } else if (references.getState == null) {\n          return undefined;\n        } else {\n          try {\n            storeState = references.getState();\n          } catch (err) {\n            if (process.env.NODE_ENV === 'development') {\n              console.warn('Invalid access attempt to a computed property');\n            }\n            return undefined;\n          }\n        }\n        const state = get(parentPath, storeState);\n        const inputs = definition.stateResolvers.map((resolver) =>\n          resolver(state, storeState),\n        );\n        return memoisedResultFn(...inputs);\n      },\n    });\n  };\n}\n\nexport function createComputedPropertiesMiddleware(references) {\n  return (store) => (next) => (action) => {\n    references.internals._computedState.currentState = store.getState();\n    references.internals._computedState.isInReducer = true;\n    return next(action);\n  };\n}\n","import { get, isPromise } from './lib';\n\nexport function createEffectsMiddleware(references) {\n  return (store) => (next) => (action) => {\n    if (references.internals._effects.length === 0) {\n      return next(action);\n    }\n    const prevState = store.getState();\n    const result = next(action);\n    const nextState = store.getState();\n    references.internals._effects.forEach((definition) => {\n      const prevLocal = get(definition.meta.parent, prevState);\n      const nextLocal = get(definition.meta.parent, nextState);\n      if (prevLocal !== nextLocal) {\n        const prevDependencies = definition.dependencyResolvers.map(\n          (resolver) => resolver(prevLocal),\n        );\n        const nextDependencies = definition.dependencyResolvers.map(\n          (resolver) => resolver(nextLocal),\n        );\n        const hasChanged = prevDependencies.some((dependency, idx) => {\n          return dependency !== nextDependencies[idx];\n        });\n        if (hasChanged) {\n          definition.actionCreator(prevDependencies, nextDependencies, action);\n        }\n      }\n    });\n    return result;\n  };\n}\n\nexport function createEffectHandler(\n  definition,\n  references,\n  injections,\n  _actionCreators,\n) {\n  const actions = get(definition.meta.parent, _actionCreators);\n  let dispose;\n  return (change) => {\n    const helpers = {\n      dispatch: references.dispatch,\n      getState: () => get(definition.meta.parent, references.getState()),\n      getStoreActions: () => _actionCreators,\n      getStoreState: references.getState,\n      injections,\n      meta: {\n        key: definition.meta.actionName,\n        parent: definition.meta.parent,\n        path: definition.meta.path,\n      },\n    };\n    if (dispose !== undefined) {\n      const disposeResult = dispose();\n      dispose = undefined;\n      if (isPromise(disposeResult)) {\n        disposeResult.catch((err) => {\n          // We don't want the user completely clueless as to an error occurring,\n          // so we'll log out to the console.\n          // eslint-disable-next-line no-console\n          console.log(err);\n        });\n      }\n    }\n    const effectResult = definition.fn(actions, change, helpers);\n\n    if (isPromise(effectResult)) {\n      return effectResult.then((resolved) => {\n        if (typeof resolved === 'function') {\n          if (process.env.NODE_ENV !== 'production') {\n            // Dispose functions are not allowed to be resolved asynchronously.\n            // Doing so would provide inconsistent behaviour around their execution.\n            // eslint-disable-next-line no-console\n            console.warn(\n              '[easy-peasy] You have an effect which is asynchronously resolving a dispose function. This is considered an anti-pattern. Please read the API documentation for more information.',\n            );\n          }\n        }\n      });\n    }\n\n    if (typeof effectResult === 'function') {\n      dispose = effectResult;\n    }\n  };\n}\n\nexport function createEffectActionsCreator(\n  definition,\n  references,\n  effectHandler,\n) {\n  const actionCreator = (previousDependencies, nextDependencies, action) => {\n    const change = {\n      prev: previousDependencies,\n      current: nextDependencies,\n      action,\n    };\n    const dispatchError = (err) =>\n      references.dispatch({\n        type: definition.meta.failType,\n        change,\n        error: err,\n      });\n    const dispatchSuccess = () =>\n      references.dispatch({\n        type: definition.meta.successType,\n        change,\n      });\n    references.dispatch({\n      type: definition.meta.startType,\n      change,\n    });\n    try {\n      const result = references.dispatch(() => effectHandler(change));\n      if (isPromise(result)) {\n        return result\n          .then((resolved) => {\n            dispatchSuccess(resolved);\n            return resolved;\n          })\n          .catch((err) => {\n            dispatchError(err);\n            // Note: you can't throw the error as the user will not be able to\n            // get a handle on the Promise.\n          });\n      }\n      dispatchSuccess(result);\n      return result;\n    } catch (err) {\n      dispatchError(err);\n      throw err;\n    }\n  };\n\n  actionCreator.type = definition.meta.type;\n  actionCreator.startType = definition.meta.startType;\n  actionCreator.successType = definition.meta.successType;\n  actionCreator.failType = definition.meta.failType;\n\n  return actionCreator;\n}\n","import {\n  applyMiddleware,\n  compose as reduxCompose,\n  createStore as reduxCreateStore,\n} from 'redux';\nimport reduxThunk from 'redux-thunk';\nimport * as helpers from './helpers';\nimport createStoreInternals from './create-store-internals';\nimport {\n  createPersistor,\n  createPersistMiddleware,\n  rehydrateStateFromPersistIfNeeded,\n} from './persistence';\nimport { createComputedPropertiesMiddleware } from './computed-properties';\nimport { createListenerMiddleware } from './listeners';\nimport { deepCloneStateWithoutComputed } from './lib';\nimport { createEffectsMiddleware } from './effects';\n\nexport default function createStore(model, options = {}) {\n  const modelClone = deepCloneStateWithoutComputed(model);\n  const {\n    compose,\n    devTools = true,\n    disableImmer = false,\n    enhancers = [],\n    initialState = {},\n    injections,\n    middleware = [],\n    mockActions = false,\n    name: storeName = `EasyPeasyStore`,\n    reducerEnhancer = (rootReducer) => rootReducer,\n  } = options;\n\n  const bindReplaceState = (modelDef) => {\n    return {\n      ...modelDef,\n      ePRS: helpers.action((_, payload) => payload),\n    };\n  };\n\n  const references = {};\n\n  let modelDefinition = bindReplaceState(modelClone);\n  let mockedActions = [];\n\n  const persistKey = (targetPath) => `[${storeName}]@${targetPath.join('.')}`;\n  const persistor = createPersistor(persistKey, references);\n  const persistMiddleware = createPersistMiddleware(persistor, references);\n\n  const replaceState = (nextState) =>\n    references.internals._actionCreatorDict['@action.ePRS'](nextState);\n\n  const bindStoreInternals = (state = {}) => {\n    references.internals = createStoreInternals({\n      disableImmer,\n      initialState: state,\n      injections,\n      model: modelDefinition,\n      reducerEnhancer,\n      references,\n    });\n  };\n\n  const mockActionsMiddleware = () => () => (action) => {\n    if (action != null) {\n      mockedActions.push(action);\n    }\n    return undefined;\n  };\n\n  const composeEnhancers =\n    compose ||\n    (devTools &&\n    typeof window !== 'undefined' &&\n    window.__REDUX_DEVTOOLS_EXTENSION_COMPOSE__\n      ? window.__REDUX_DEVTOOLS_EXTENSION_COMPOSE__({\n          name: storeName,\n        })\n      : reduxCompose);\n\n  bindStoreInternals(initialState);\n\n  const easyPeasyMiddleware = [\n    createComputedPropertiesMiddleware(references),\n    ...middleware,\n    reduxThunk,\n    createListenerMiddleware(references),\n    createEffectsMiddleware(references),\n    persistMiddleware,\n  ];\n\n  if (mockActions) {\n    easyPeasyMiddleware.push(mockActionsMiddleware);\n  }\n\n  const store = reduxCreateStore(\n    references.internals.reducer,\n    references.internals._defaultState,\n    composeEnhancers(applyMiddleware(...easyPeasyMiddleware), ...enhancers),\n  );\n\n  store.subscribe(() => {\n    references.internals._computedState.isInReducer = false;\n  });\n\n  references.dispatch = store.dispatch;\n  references.getState = store.getState;\n\n  const bindActionCreators = () => {\n    Object.keys(store.dispatch).forEach((actionsKey) => {\n      delete store.dispatch[actionsKey];\n    });\n    Object.keys(references.internals._actionCreators).forEach((key) => {\n      store.dispatch[key] = references.internals._actionCreators[key];\n    });\n  };\n\n  bindActionCreators();\n\n  const rebindStore = (removeKey) => {\n    const currentState = store.getState();\n    if (removeKey) {\n      delete currentState[removeKey];\n    }\n    bindStoreInternals(currentState);\n    store.replaceReducer(references.internals.reducer);\n    replaceState(references.internals._defaultState);\n    bindActionCreators();\n  };\n\n  const resolveRehydration = rehydrateStateFromPersistIfNeeded(\n    persistKey,\n    replaceState,\n    references,\n  );\n\n  return Object.assign(store, {\n    addModel: (key, modelForKey) => {\n      if (modelDefinition[key] && process.env.NODE_ENV !== 'production') {\n        // eslint-disable-next-line no-console\n        console.warn(\n          `easy-peasy: The store model already contains a model definition for \"${key}\"`,\n        );\n        store.removeModel(key);\n      }\n      modelDefinition[key] = modelForKey;\n      rebindStore();\n      // There may have been persisted state for a dynamic model. We should try\n      // and rehydrate the specifc node\n      const addModelRehydration = rehydrateStateFromPersistIfNeeded(\n        persistKey,\n        replaceState,\n        references,\n        key,\n      );\n      return {\n        resolveRehydration: () => addModelRehydration,\n      };\n    },\n    clearMockedActions: () => {\n      mockedActions = [];\n    },\n    getActions: () => references.internals._actionCreators,\n    getListeners: () => references.internals._listenerActionCreators,\n    getMockedActions: () => [...mockedActions],\n    persist: {\n      clear: persistor.clear,\n      flush: persistor.flush,\n      resolveRehydration: () => resolveRehydration,\n    },\n    reconfigure: (newModel) => {\n      modelDefinition = bindReplaceState(newModel);\n      rebindStore();\n    },\n    removeModel: (key) => {\n      if (!modelDefinition[key]) {\n        if (process.env.NODE_ENV !== 'production') {\n          // eslint-disable-next-line no-console\n          console.warn(\n            `easy-peasy: The store model does not contain a model definition for \"${key}\"`,\n          );\n        }\n        return;\n      }\n      delete modelDefinition[key];\n      rebindStore(key);\n    },\n  });\n}\n","import createReducer from './create-reducer';\nimport extractDataFromModel from './extract-data-from-model';\n\nexport default function createStoreInternals({\n  disableImmer,\n  initialState,\n  injections,\n  model,\n  reducerEnhancer,\n  references,\n}) {\n  const {\n    _actionCreatorDict,\n    _actionCreators,\n    _actionReducersDict,\n    _computedState,\n    _computedProperties,\n    _customReducers,\n    _defaultState,\n    _effects,\n    _listenerActionCreators,\n    _listenerActionMap,\n    _persistenceConfig,\n  } = extractDataFromModel(model, initialState, injections, references);\n\n  const rootReducer = createReducer(\n    disableImmer,\n    _actionReducersDict,\n    _customReducers,\n    _computedProperties,\n  );\n\n  return {\n    _actionCreatorDict,\n    _actionCreators,\n    _computedProperties,\n    _computedState,\n    _defaultState,\n    _effects,\n    _listenerActionCreators,\n    _listenerActionMap,\n    _persistenceConfig,\n    reducer: reducerEnhancer(rootReducer),\n  };\n}\n","import isPlainObject from 'is-plain-object';\nimport {\n  actionOnSymbol,\n  actionSymbol,\n  computedSymbol,\n  effectOnSymbol,\n  persistSymbol,\n  reducerSymbol,\n  thunkOnSymbol,\n  thunkSymbol,\n} from './constants';\nimport { get, set } from './lib';\nimport { extractPersistConfig } from './persistence';\nimport { createActionCreator } from './actions';\nimport { createThunkHandler, createThunkActionsCreator } from './thunks';\nimport { bindListenerDefinitions } from './listeners';\nimport { createComputedPropertyBinder } from './computed-properties';\nimport { createEffectHandler, createEffectActionsCreator } from './effects';\n\nexport default function extractDataFromModel(\n  model,\n  initialState,\n  injections,\n  references,\n) {\n  const _defaultState = initialState;\n  const _actionCreatorDict = {};\n  const _actionCreators = {};\n  const _actionReducersDict = {};\n  const actionThunks = {};\n  const _computedProperties = [];\n  const _customReducers = [];\n  const _effects = [];\n  const _listenerActionCreators = {};\n  const _listenerActionMap = {};\n  const listenerDefinitions = [];\n  const _persistenceConfig = [];\n  const _computedState = {\n    isInReducer: false,\n    currentState: _defaultState,\n  };\n\n  const recursiveExtractFromModel = (current, parentPath) =>\n    Object.keys(current).forEach((key) => {\n      const value = current[key];\n      const path = [...parentPath, key];\n      const meta = {\n        parent: parentPath,\n        path,\n        key,\n      };\n      const handleValueAsState = () => {\n        const initialParentRef = get(parentPath, initialState);\n        if (initialParentRef && key in initialParentRef) {\n          set(path, _defaultState, initialParentRef[key]);\n        } else {\n          set(path, _defaultState, value);\n        }\n      };\n\n      if (key === persistSymbol) {\n        _persistenceConfig.push(extractPersistConfig(parentPath, value));\n        return;\n      }\n\n      if (value != null && typeof value === 'object') {\n        if (value[actionSymbol] || value[actionOnSymbol]) {\n          const definition = { ...value };\n\n          // Determine the category of the action\n          const category = definition[actionSymbol] ? '@action' : '@actionOn';\n\n          // Establish the meta data describing the action\n          definition.meta = {\n            actionName: meta.key,\n            category,\n            type: `${category}.${meta.path.join('.')}`,\n            parent: meta.parent,\n            path: meta.path,\n          };\n\n          // Create the \"action creator\" function\n          definition.actionCreator = createActionCreator(\n            definition,\n            references,\n          );\n\n          // Create a bidirectional relationship of the definition/actionCreator\n          definition.actionCreator.definition = definition;\n\n          // Create a bidirectional relationship of the definition/reducer\n          definition.fn.definition = definition;\n\n          // Add the action creator to lookup map\n          _actionCreatorDict[definition.meta.type] = definition.actionCreator;\n\n          // Add the reducer to lookup map\n          _actionReducersDict[definition.meta.type] = definition.fn;\n\n          // We don't want to expose the internal action to consumers\n          if (meta.key !== 'ePRS') {\n            // Set the action creator in the \"actions\" object tree for\n            // either the listeners object tree, or the standard actions/thunks\n            // object tree\n            if (definition[actionOnSymbol]) {\n              listenerDefinitions.push(definition);\n              set(path, _listenerActionCreators, definition.actionCreator);\n            } else {\n              set(path, _actionCreators, definition.actionCreator);\n            }\n          }\n        } else if (value[thunkSymbol] || value[thunkOnSymbol]) {\n          const definition = { ...value };\n\n          // Determine the category of the thunk\n          const category = definition[thunkSymbol] ? '@thunk' : '@thunkOn';\n\n          // Establish the meta data describing the thunk\n          const type = `${category}.${meta.path.join('.')}`;\n          definition.meta = {\n            actionName: meta.key,\n            parent: meta.parent,\n            path: meta.path,\n            type,\n            startType: `${type}(start)`,\n            successType: `${type}(success)`,\n            failType: `${type}(fail)`,\n          };\n\n          // Create the function that will handle, i.e. be executed, when\n          // the thunk action is created/dispatched\n          definition.thunkHandler = createThunkHandler(\n            definition,\n            references,\n            injections,\n            _actionCreators,\n          );\n\n          // Register the thunk handler\n          set(path, actionThunks, definition.thunkHandler);\n\n          // Create the \"action creator\" function\n          definition.actionCreator = createThunkActionsCreator(\n            definition,\n            references,\n          );\n\n          // Create a bidirectional relationship of the definition/actionCreator\n          definition.actionCreator.definition = definition;\n\n          // Register the action creator within the lookup map\n          _actionCreatorDict[definition.meta.type] = definition.actionCreator;\n\n          // Set the action creator in the \"actions\" object tree for\n          // either the listeners object tree, or the standard actions/thunks\n          // object tree\n          if (definition[thunkOnSymbol]) {\n            listenerDefinitions.push(definition);\n            set(path, _listenerActionCreators, definition.actionCreator);\n          } else {\n            set(path, _actionCreators, definition.actionCreator);\n          }\n        } else if (value[computedSymbol]) {\n          const parent = get(parentPath, _defaultState);\n          const bindComputedProperty = createComputedPropertyBinder(\n            parentPath,\n            key,\n            value,\n            _computedState,\n            references,\n          );\n          bindComputedProperty(parent);\n          _computedProperties.push({ key, parentPath, bindComputedProperty });\n        } else if (value[reducerSymbol]) {\n          _customReducers.push({ key, parentPath, reducer: value.fn });\n        } else if (value[effectOnSymbol]) {\n          const definition = { ...value };\n\n          // Establish the meta data describing the effect\n          const type = `@effectOn.${meta.path.join('.')}`;\n          definition.meta = {\n            type,\n            actionName: meta.key,\n            parent: meta.parent,\n            path: meta.path,\n            startType: `${type}(start)`,\n            successType: `${type}(success)`,\n            failType: `${type}(fail)`,\n          };\n\n          const effectHandler = createEffectHandler(\n            definition,\n            references,\n            injections,\n            _actionCreators,\n          );\n\n          const actionCreator = createEffectActionsCreator(\n            definition,\n            references,\n            effectHandler,\n          );\n\n          definition.actionCreator = actionCreator;\n\n          _effects.push(definition);\n        } else if (isPlainObject(value)) {\n          const existing = get(path, _defaultState);\n          if (existing == null) {\n            set(path, _defaultState, {});\n          }\n          recursiveExtractFromModel(value, path);\n        } else {\n          handleValueAsState();\n        }\n      } else {\n        handleValueAsState();\n      }\n    });\n\n  recursiveExtractFromModel(model, []);\n\n  bindListenerDefinitions(\n    listenerDefinitions,\n    _actionCreators,\n    _actionCreatorDict,\n    _listenerActionMap,\n  );\n\n  return {\n    _actionCreatorDict,\n    _actionCreators,\n    _actionReducersDict,\n    _computedProperties,\n    _customReducers,\n    _computedState,\n    _defaultState,\n    _effects,\n    _listenerActionCreators,\n    _listenerActionMap,\n    _persistenceConfig,\n  };\n}\n","export const actionSymbol = '$ep_a';\nexport const actionOnSymbol = '$ep_aO';\nexport const computedSymbol = '$ep_c';\nexport const effectOnSymbol = '$ep_e';\nexport const persistSymbol = '$ep_p';\nexport const reducerSymbol = '$ep_r';\nexport const thunkOnSymbol = '$ep_tO';\nexport const thunkSymbol = '$ep_t';\n","import { actionOnSymbol } from './constants';\n\nexport function createActionCreator(definition, references) {\n  const actionCreator = (payload) => {\n    const action = {\n      type: definition.meta.type,\n      payload,\n    };\n    if (definition[actionOnSymbol] && definition.meta.resolvedTargets) {\n      payload.resolvedTargets = [...definition.meta.resolvedTargets];\n    }\n    return references.dispatch(action);\n  };\n\n  // We bind the types to the creator for easy reference by consumers\n  actionCreator.type = definition.meta.type;\n\n  return actionCreator;\n}\n","import { thunkOnSymbol } from './constants';\nimport { get, isPromise } from './lib';\n\nexport function createThunkHandler(\n  definition,\n  references,\n  injections,\n  _actionCreators,\n) {\n  return (payload) => {\n    const helpers = {\n      dispatch: references.dispatch,\n      getState: () => get(definition.meta.parent, references.getState()),\n      getStoreActions: () => _actionCreators,\n      getStoreState: references.getState,\n      injections,\n      meta: {\n        key: definition.meta.actionName,\n        parent: definition.meta.parent,\n        path: definition.meta.path,\n      },\n    };\n    if (definition[thunkOnSymbol] && definition.meta.resolvedTargets) {\n      payload.resolvedTargets = [...definition.meta.resolvedTargets];\n    }\n    return definition.fn(\n      get(definition.meta.parent, _actionCreators),\n      payload,\n      helpers,\n    );\n  };\n}\n\nexport function createThunkActionsCreator(definition, references) {\n  const actionCreator = (payload) => {\n    const dispatchError = (err) => {\n      references.dispatch({\n        type: definition.meta.failType,\n        payload,\n        error: err,\n      });\n      references.dispatch({\n        type: definition.meta.type,\n        payload,\n        error: err,\n      });\n    };\n    const dispatchSuccess = (result) => {\n      references.dispatch({\n        type: definition.meta.successType,\n        payload,\n        result,\n      });\n      references.dispatch({\n        type: definition.meta.type,\n        payload,\n        result,\n      });\n    };\n\n    references.dispatch({\n      type: definition.meta.startType,\n      payload,\n    });\n    try {\n      const result = references.dispatch(() =>\n        definition.thunkHandler(payload),\n      );\n      if (isPromise(result)) {\n        return result\n          .then((resolved) => {\n            dispatchSuccess(resolved);\n            return resolved;\n          })\n          .catch((err) => {\n            dispatchError(err);\n            throw err;\n          });\n      }\n      dispatchSuccess(result);\n      return result;\n    } catch (err) {\n      dispatchError(err);\n      throw err;\n    }\n  };\n\n  actionCreator.type = definition.meta.type;\n  actionCreator.successType = definition.meta.successType;\n  actionCreator.failType = definition.meta.failType;\n  actionCreator.startType = definition.meta.startType;\n\n  return actionCreator;\n}\n","import { useMemo, useState, useRef, useEffect } from 'react';\nimport createStore from './create-store';\n\nlet notified = false;\n\n/**\n * Some good references on the topic of reinitialisation:\n * - https://github.com/facebook/react/issues/14830\n */\n\nexport default function createComponentStore(model, config) {\n  if (!notified) {\n    notified = true;\n    if (process.env.NODE_ENV === 'development') {\n      console.log(`easy-peasy: Deprecation Warning.\n\nYou are using the createComponentStore API. This API has been deprecated and will be removed in the next major release.\n\nWe recommend that you instead use the newer useLocalStore API, which is a much more flexible and concise API:\n\n    https://easy-peasy.now.sh/docs/api/use-local-store.html\n`);\n    }\n  }\n\n  return function useLocalStore(initialData) {\n    const store = useMemo(\n      () =>\n        createStore(\n          typeof model === 'function' ? model(initialData) : model,\n          config,\n        ),\n      [],\n    );\n    const previousStateRef = useRef(store.getState());\n    const [currentState, setCurrentState] = useState(() => store.getState());\n    useEffect(() => {\n      return store.subscribe(() => {\n        const nextState = store.getState();\n        if (previousStateRef.current !== nextState) {\n          previousStateRef.current = nextState;\n          setCurrentState(nextState);\n        }\n      });\n    }, [store]);\n    return [currentState, store.getActions()];\n  };\n}\n","import { setAutoFreeze } from 'immer';\nimport {\n  createTypedHooks,\n  useStoreActions,\n  useStoreDispatch,\n  useStoreState,\n  useStoreRehydrated,\n  useStore,\n} from './hooks';\nimport createStore from './create-store';\nimport createContextStore from './create-context-store';\nimport createComponentStore from './create-component-store';\nimport createTransform from './create-transform';\nimport StoreProvider from './provider';\nimport useLocalStore from './use-local-store';\nimport {\n  action,\n  actionOn,\n  computed,\n  debug,\n  generic,\n  memo,\n  persist,\n  reducer,\n  thunk,\n  thunkOn,\n  unstable_effectOn,\n} from './helpers';\n\n/**\n * The auto freeze feature of immer doesn't seem to work in our testing. We have\n * explicitly disabled it to avoid perf issues.\n */\nsetAutoFreeze(false);\n\nexport {\n  action,\n  actionOn,\n  computed,\n  createComponentStore,\n  createContextStore,\n  createStore,\n  createTransform,\n  createTypedHooks,\n  debug,\n  generic,\n  memo,\n  persist,\n  reducer,\n  StoreProvider,\n  thunk,\n  thunkOn,\n  unstable_effectOn,\n  useLocalStore,\n  useStoreActions,\n  useStoreDispatch,\n  useStoreState,\n  useStoreRehydrated,\n  useStore,\n};\n","import React from 'react';\nimport StoreContext from './context';\n\nexport default function StoreProvider({ children, store }) {\n  return (\n    <StoreContext.Provider value={store}>{children}</StoreContext.Provider>\n  );\n}\n","/* eslint-disable react/prop-types */\n\nimport React, { createContext, useContext } from 'react';\nimport { useMemoOne } from 'use-memo-one';\nimport {\n  createStoreActionsHook,\n  createStoreDispatchHook,\n  createStoreStateHook,\n  createStoreRehydratedHook,\n} from './hooks';\nimport createStore from './create-store';\n\nexport default function createContextStore(model, config) {\n  const StoreContext = createContext();\n\n  function Provider({ children, initialData }) {\n    const store = useMemoOne(\n      () =>\n        createStore(\n          typeof model === 'function' ? model(initialData) : model,\n          config,\n        ),\n      [],\n    );\n    return (\n      <StoreContext.Provider value={store}>{children}</StoreContext.Provider>\n    );\n  }\n\n  function useStore() {\n    return useContext(StoreContext);\n  }\n\n  return {\n    Provider,\n    useStore,\n    useStoreState: createStoreStateHook(StoreContext),\n    useStoreActions: createStoreActionsHook(StoreContext),\n    useStoreDispatch: createStoreDispatchHook(StoreContext),\n    useStoreRehydrated: createStoreRehydratedHook(StoreContext),\n  };\n}\n","/**\n * This file has been copied from redux-persist.\n * The intention being to support as much of the redux-persist API as possible.\n */\n\nexport default function createTransform(inbound, outbound, config = {}) {\n  const whitelist = config.whitelist || null;\n  const blacklist = config.blacklist || null;\n\n  function whitelistBlacklistCheck(key) {\n    if (whitelist && whitelist.indexOf(key) === -1) return true;\n    if (blacklist && blacklist.indexOf(key) !== -1) return true;\n    return false;\n  }\n\n  return {\n    in: (data, key, fullState) =>\n      !whitelistBlacklistCheck(key) && inbound\n        ? inbound(data, key, fullState)\n        : data,\n    out: (data, key, fullState) =>\n      !whitelistBlacklistCheck(key) && outbound\n        ? outbound(data, key, fullState)\n        : data,\n  };\n}\n","import { useEffect, useRef, useState } from 'react';\nimport { useMemoOne } from 'use-memo-one';\nimport createStore from './create-store';\n\nexport default function useLocalStore(\n  modelCreator,\n  dependencies = [],\n  configCreator,\n) {\n  const storeRef = useRef();\n\n  const configRef = useRef();\n\n  const store = useMemoOne(() => {\n    const previousState =\n      storeRef.current != null ? storeRef.current.getState() : undefined;\n    const config =\n      configCreator != null\n        ? configCreator(previousState, configRef.current)\n        : undefined;\n    const _store = createStore(modelCreator(previousState), config);\n    configRef.current = config;\n    storeRef.current = _store;\n    return _store;\n  }, dependencies);\n\n  const [currentState, setCurrentState] = useState(() => store.getState());\n\n  useEffect(() => {\n    return store.subscribe(() => {\n      const nextState = store.getState();\n      if (currentState !== nextState) {\n        setCurrentState(nextState);\n      }\n    });\n  }, [store]);\n\n  return [currentState, store.getActions(), store];\n}\n"],"names":["StoreContext","createContext","useIsomorphicLayoutEffect","window","useLayoutEffect","useEffect","createStoreStateHook","Context","mapState","equalityFn","store","useContext","mapStateRef","useRef","stateRef","mountedRef","subscriptionMapStateError","forceRender","useReducer","s","current","undefined","getState","err","process","env","NODE_ENV","errorMessage","message","stack","Error","checkMapState","newState","unsubscribe","subscribe","useStoreState","EasyPeasyContext","createStoreActionsHook","mapActions","getActions","useStoreActions","createStoreDispatchHook","dispatch","useStoreDispatch","useStore","createStoreRehydratedHook","useState","rehydrated","setRehydrated","persist","resolveRehydration","then","useStoreRehydrated","action","fn","defaultStateResolvers","state","deepCloneStateWithoutComputed","source","recursiveClone","next","Object","keys","reduce","acc","key","getOwnPropertyDescriptor","get","forEach","isPlainObject","isPromise","x","path","target","cur","set","value","length","idx","createReducer","disableImmer","_actionReducersDict","_customReducers","_computedProperties","simpleProduce","newify","currentPath","currentState","finalValue","slice","draft","createDraft","result","isDraft","finishDraft","parentPath","parent","createSimpleProduce","stateAfterActions","actionReducer","type","payload","runActionReducerAtPath","definition","meta","reducerForActions","red","reducer","reducerForCustomReducers","bindComputedProperty","prop","noopStorage","getItem","setItem","removeItem","getStorage","storageName","_","localStorage","sessionStorage","createStorageWrapper","storage","transformers","console","warn","outTransformers","reverse","deserialize","data","simpleKey","substr","indexOf","JSON","parse","out","isAsync","wrapped","transformed","stringify","serialize","resolvePersistTargets","whitelist","blacklist","targets","findIndex","createPersistenceClearer","persistKey","references","Promise","resolve","reject","internals","_persistenceConfig","config","all","map","targetPath","rehydrateStateFromPersistIfNeeded","replaceState","root","persistInstance","mergeStrategy","_defaultState","hasDataModelChanged","dataModel","rehydratingModelData","Array","isArray","applyRehydrationStrategy","originalState","rehydratedState","setAt","currentTarget","currentNext","asyncStateResolvers","dataPromise","push","resolvedData","createListenerMiddleware","_listenerActionMap","sourceAction","_actionCreatorDict","actionCreator","error","createComputedPropertiesMiddleware","_computedState","isInReducer","createEffectsMiddleware","_effects","prevState","nextState","prevLocal","nextLocal","prevDependencies","dependencyResolvers","resolver","nextDependencies","some","dependency","createStore","model","options","modelClone","compose","devTools","enhancers","initialState","injections","middleware","mockActions","name","storeName","reducerEnhancer","rootReducer","bindReplaceState","modelDef","ePRS","helpers","modelDefinition","mockedActions","join","persistor","persistPromise","debounce","concat","clear","flush","createPersistor","persistMiddleware","createPersistMiddleware","bindStoreInternals","_actionCreators","actionThunks","_listenerActionCreators","listenerDefinitions","recursiveExtractFromModel","handleValueAsState","initialParentRef","category","actionName","resolvedTargets","createActionCreator","startType","successType","failType","thunkHandler","getStoreActions","getStoreState","createThunkHandler","dispatchError","dispatchSuccess","resolved","createThunkActionsCreator","memoisedResultFn","memoizerific","o","defineProperty","configurable","enumerable","storeState","inputs","stateResolvers","createComputedPropertyBinder","effectHandler","dispose","actions","change","disposeResult","log","effectResult","createEffectHandler","previousDependencies","prev","createEffectActionsCreator","persistDefinition","extractPersistConfig","targetResolver","targetTypes","targetType","listenerReg","bindListenerDefinitions","extractDataFromModel","createStoreInternals","composeEnhancers","__REDUX_DEVTOOLS_EXTENSION_COMPOSE__","reduxCompose","easyPeasyMiddleware","reduxThunk","reduxCreateStore","applyMiddleware","bindActionCreators","actionsKey","rebindStore","removeKey","replaceReducer","assign","addModel","modelForKey","removeModel","addModelRehydration","clearMockedActions","getListeners","getMockedActions","reconfigure","newModel","notified","setAutoFreeze","React","Provider","children","fnOrStateResolvers","initialData","useMemo","previousStateRef","setCurrentState","useMemoOne","inbound","outbound","whitelistBlacklistCheck","in","fullState","cacheSize","modelCreator","dependencies","configCreator","storeRef","configRef","previousState","_store"],"mappings":"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"}